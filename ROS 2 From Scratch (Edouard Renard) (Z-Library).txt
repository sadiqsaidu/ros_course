


1
        Introduction to ROS 2 - What Is ROS 2?
Robot Operating System (ROS) can be confusing, as evidenced by its name. It's difficult to know what it is exactly, what it contains, and what it does. Also, why do you even need ROS, and when should you use it?
Before getting started, it is okay to be confused-most people are. Although ROS is one of the best tools to learn and develop robotics applications, it also comes with a steep learning curve, with the first roadblock being understanding what it is.
In this quick first chapter, I will explain the terminology we will use throughout this book. You will then see why ROS exists, and what problems it can solve for you. After that, we will dive a bit deeper into the four pillars of ROS to understand what it is. You will also see a few examples of when and when not to use it.
By the end of this chapter, you will have a better understanding of the global picture behind ROS and be clear of the most common confusions. You will also understand what prerequisites you need before you get started with ROS, as well as how to follow this book to get the most out of it. This will help you get started on the right foot.
In this chapter, we are going to cover the following topics:
• Terminology
• What is ROS, when should we use it, and why?
• ROS 1 versus ROS 2
• Prerequisites for starting with ROS 2
• How to follow this book

Terminology
You might have seen the terms ROS, ROS 1, ROS 2, and other kinds of variations (with or without a space), which can be confusing.
Let's clear this up now:
• ROS 1 is (was) the first version of ROS
   • ROS 2 is the second and newer version of ROS and will be the focus of this book In this book, I will use the following convention:
• ROS: When talking about general ROS concepts, philosophy, and so on
• ROS 1: When talking specifically about the first version of ROS. However, this will be quite rare since the focus here is on ROS 2
• ROS 2: When talking about the second version of ROS


What is ROS, when should we use it, and why?
Before we start understanding what ROS is, let's understand why we would need it.

Why ROS?
Let's start with a big problem that occurs often in robotics.
Imagine that you just got a new project at your job, and you have to develop a robotics application, or you are doing a new research thesis. One very important thing to take into account is that in real life, any project or thesis will have a specific duration, from a few months to a few years.
Now, what will happen?

You start to design the robotics system you need for your project and soon realize that it will take a lot of time to develop the robot because all the existing solutions you found don't match what you need. After a few weeks, you finalize the specifications, and you start building your robot. A few months in, you're still developing the basic software for wheel control and navigation. You underestimated how much time it would take you to just get the robot running. After 1 or 2 years, you realize that all you've done for now is build a robotics system, and you still haven't started the core functionality of your application or research. Now is the time to hurry.
You finish the robot as well as you can, make some shortcuts, and publish your paper or present that prototype. In the best-case scenario, you could also share your code with an open-source license so that other people can use it, but probably not directly as it's just code for your own need, not a complete framework or library with modular components, documentation, and so on.
Then, you move on to a new project, new job, and new research. Somebody else will take your place, read your code, and realize that it doesn't help them build their application. Hence, they have to start from scratch.
What just happened here is that you reinvented the wheel. The next person will repeat the same circle. And this is much more common than you think. People keep reinventing the wheel over and over again. This is the number one reason why ROS was created: to stop you from reinventing the wheel anytime you need to create a robot. Just like you have open-source frameworks, tools, and environments to develop websites or mobile applications, why not do the same for robotics? This is the philosophy behind ROS: to provide a standard for robotics applications that you can use on any robot.
After you learn ROS, you can spend less time on the basics and focus on the key functionalities you want to add instead. You can program new robots in no time, join existing projects, and easily collaborate with a team.

What is ROS?
ROS is hard to define because it's not just one thing. And to be honest, I don't think you can truly understand what it is until you start to understand how to write code with it.
One thing we can start with is what ROS is not.
ROS is not an operating system. It's a combination of four main parts:
• Framework
• Set of tools
• Plug-and-play plugins
• An online community

Let's dive a bit more into each of these parts.
ROS is a framework with plumbing
ROS comes with a set of rules on how to build an application. As we will see in this book, you will need to create packages, and then write programs inside those packages (nodes). There is a specific way to create and write them, as well as create tools to build and use them.
Any framework comes with a specific set of rules. The remarkable thing about this is that after you've created a few projects, any new project is going to be easier and faster to set up. Also, as everyone is following the same set of rules, you can more easily work in a team or understand and use the code written by others.
As a direct consequence of using this framework, you get access to what is often referred to as plumbing, which means that the underlying communication between the nodes is managed for you. Imagine that you're building a house, and the plumbing or electrical system is already done for you. This will save you a lot of development time, and you also don't need to learn how to do it yourself (and thus, reinvent the wheel).
To sum it up, with ROS, you can easily separate your application into different sub-programs (called nodes). The communication between nodes is handled for you. You can easily test one component, and if this component fails, it will not affect the other running components. ROS is a modular framework.
A set of tools
ROS comes with a set of tools that allow you to develop faster. Among them, you can find command- line tools to build the application, introspection tools to monitor the flow of communication, logging functionalities, plots, and more.
You also get 3D visualization tools to see what your robot is doing, and even a complete simulator using real physics, named Gazebo, so that you can work on a realistic simulation before trying out your robot.
There are quite a lot of available tools, and we'll discover many of them throughout this book. As an example of how useful it can be, there is one (called bags) that allows you to save communication streams so that they can be replayed later. Let's say you build a mobile robot, and you need to test the robot outside when it's raining, then continue to develop the software while taking the rain into account. You probably won't have rain every day, or you won't even have access to the robot any time you want. With this tool, you can run the experiment once, save the data, and replay it later to develop your application for a specific set of conditions.

Capabilities - plug-and-play plugins and stacks
This is probably where you will save hundreds of hours. Imagine two common scenarios:
• You develop a mobile robot and need the robot to navigate autonomously in a dynamic environment.
• You develop a six-axis robotic arm and want to create motion planning to perform a smooth movement on all axes.
This looks quite complex and involves understanding and implementing several algorithms, as well as writing well-optimized and efficient code. This is where you would probably have to reinvent the wheel and waste lots of precious time.
For those two scenarios, you can find existing plugins that do the job for you. All you need to do is install the plugins and configure your robot to make it compatible. Of course, this is easier said than done, but the workload can be counted in days/weeks, not months/years. And once again, once you know how to use those plugins, your next project will take much less time.
There are many plugins that you can use. Some are quite simple, while others involve a collection of plugins and are also called frameworks or stacks. Your job as a ROS developer is to glue all those components together, and maybe create new components for functionalities that are not developed yet.
Online community
This is the fourth pillar of ROS, and it's quite an important one: the community. ROS is an open-source project with a permissive license. I can't give you any legal advice on licensing, but you can use ROS in a commercial product without having to redistribute your code.
You can find all the ROS code online, as well as the code for the plug-and-play plugins. Everything is easily accessible on GitHub.
The ROS project is also backed by an online community that you can most commonly find in the following areas:
• Robotics Stack Exchange (https://robotics.stackexchange.com/): You can use this to ask technical questions. If you know Stack Overflow, as most developers do, well, this is Stack Overflow for robotics.
• ROS Discourse forums (https://discourse.ros.org/): Here, you can get informed about the latest developments, jobs, community projects, new ideas, and more. I recommend checking this website often to stay up to date with where ROS is going.

When to use ROS
Now that you understand a bit more what ROS is, should you use ROS whenever your project has something 'robotics' in it? In this section, I will give you some hints on when using ROS makes sense, backed by some examples to give you a better idea.
First, if you're reading this book because you need to learn ROS for your work/university, then the question is easily answered: yes, you will use ROS for your project.
But if you must make the decision yourself, what should you do?
Let's simplify robotics and say that a robotics system contains three categories of things: actuators, sensors, and controllers.
An actuator is something that creates movement (for example, a motor to rotate a wheel). A sensor will read data from the environment (for example, a camera, laser scan, or temperature sensor). A controller is something that is in between: it takes the data available from one or multiple sensors (input) and, through an algorithm, creates a command for the actuators of the robot (output). In a way, the controller is the brain or one of the brains of the robot.
For very simple applications, when you just have a few sensors and actuators, you might not need ROS. Here are a few examples where ROS isn't needed:
• You just need to take a picture from a camera when a user presses a button, using a Raspberry Pi board, and send this picture to a web server. There's no need to use ROS-you can just combine a few Python libraries in a script, and you're done. Using ROS here would be a good example of over-engineering (unless you do this for learning purposes).
• You have to use a servo motor to open/close a door when a movement is detected, using an infrared sensor. This is a very simple application that can easily be programmed using a basic microcontroller board-and you can do a quick prototype with a board such as Arduino.
• You have built a simple robot with two wheels and an infrared sensor, and you want to make the robot follow a line. This is a typical project that's given to students in engineering school, and a simple algorithm on an Arduino board will do.
Now, let's consider some examples where ROS is needed:
• You have a new mobile robot with two wheels and a laser scan, and you want to read data from the laser scan, map the environment, make the robot move autonomously, and control the two wheels accordingly. On top of that, you want to simulate the robot in 3D with real physical properties. This is when ROS is going to become very handy. Not only will it help you to make all the components work together, but you can also use existing algorithms for path planning (through a ROS plugin) and simulation.

• You need to create a system that contains a six-axis robotic arm, or even multiple robotic arms working together, along with conveyor belts and mobile robots.
• Your robotics application (not necessarily just one robot) contains lots of sensors and actuators that you want to develop separately and add them in a modular way.
• You want to create a hardware driver for a component and make this component easy to use by other robotics developers. By making the component ROS-compatible, anybody who knows ROS can integrate it into their application with low effort.
As you can see from the former examples, ROS is not always needed whenever you need to program hardware or create a robotics system. Of course, you could use it for any application, but it's like if you were to use a complete web framework (for example, Django) for a single static web page.
With the latter examples, you can see that if your system becomes more complex, if you want to easily collaborate with other developers, or if you realize that one big part of your system can be solved with one of the plug-and-play plugins, ROS may be the solution.
Of course, it takes time to learn it and your first project will take longer to complete, but then, with more experience, you will go much faster.
As an example, it could take less than a week for a senior ROS developer to write custom code for a robotic arm (including robot model, motion planning, and hardware control) and the same for a mobile robot with navigation capabilities (provided that the hardware already has a ROS driver). Less than a week and you get a working software prototype.

ROS 1 versus ROS 2
To be clear, this book is all about ROS 2, not ROS 1. You will start learning ROS 2 from zero experience. This section is probably the only time I will be talking that much about ROS 1.

A quick story of ROS, and how we got to ROS 2
ROS 1 (originally called ROS) was first developed in 2007. It quickly gained popularity and grew exponentially in the following years.
In 2014, the ROS 2 project was announced. Simply put, ROS 1 was a bit too limited for industrial applications (lack of real-time support, safety, and so on) and was only used in research/education. To solve this problem, the developers decided to make ROS more "industrial friendly," as well as make it better, thanks to all the lessons learned from the beginning of ROS.
Now, why create ROS 2 and not just continue ROS with some new changes? Well, the changes were too big, and they would have completely broken compatibility with older versions. Thus, it was decided to create a completely new ROS from scratch and name it ROS 2. In 2014, ROS 2 was officially announced, and the development of the project started.

In December 2017, the first ROS 2 distribution was released, which meant that ROS 1 and ROS 2 started to co-exist. At this point, ROS 2 was lacking many core functionalities and plugins, making it unsuitable for serious projects. Most ROS developers were still using ROS 1.
Years passed by and ROS 2 got more development, plugins, and more. Its popularity started to grow.
I would say it was worth it to use ROS 2 (compared to ROS 1) starting from 2022. This is probably more of a personal opinion and some people might disagree, but from 2022 and the release of ROS 2 Humble (more on distributions in Chapter 2), we had access to a long-term release that was stable, with all the major plugins and stacks working correctly, which is what you need to program a robot.
In the meantime, it was announced that ROS 1 would end in May 2025. After this date, ROS 1 would still exist, but it wouldn't be supported anymore.
2023 was the year with the most significant shift from ROS 1 to ROS 2 among the ROS community. It is now safe to say that ROS 2 is the way to go when developing new ROS applications.
So, if you had previously heard about ROS 1 and ROS 2, now you know that ROS 2 is what you need to learn, and we can say that ROS 1 is a dead project. But is that true?

Is ROS 1 dead already?
In theory, yes, but in practice, it's (always) a bit different. As you probably know, several companies are using obsolete and legacy technologies. The reason is that updating software to a new version is often quite expensive and can also be risky. That's why you still see job offers from banking systems requiring skills in Cobol, a programming language from the 1960s that no one uses anymore.
In robotics, things are a bit similar. Some companies have released robots with a specific version of ROS 1, and while the robot is still on the market, the company will not upgrade and still use and maintain the previous version, also called legacy. Thus, the definitive transition in 2025 is going to take a few more years.
Why am I writing this? Simply to let you know that if you happen to get a job in a robotics company that has been using ROS already, you might encounter a few ROS 1 projects, even after ROS 1 is officially finished. However, be assured that all the ROS 2 knowledge you have can easily be ported to ROS 1 as the core concepts are the same.
To conclude, for all new learnings, projects, studies, teaching, and startups, ROS 2 is what you need. I will now close this chapter of ROS 1 and focus on ROS 2. As mentioned previously, I might write ROS or ROS 2 interchangeably as we aren't targeting ROS 1 here.

Prerequisites for starting with ROS 2
To get started with ROS and this book, there are a few things you need to know.

Knowledge prerequisites
It is best that you have some knowledge of the following:
• Linux command line: Since we'll be using Ubuntu, being familiar with Linux is mandatory. You don't need to be an expert-you just need to know the basics. Many tools in ROS 2 involve the command line, so knowing how to open a Terminal and write basic commands will help you tremendously.
• Python programming: The two most common languages for ROS are Python and C++. Python is easier to get started with and allows you to prototype things faster. Hence, this is the language we will use for all detailed explanations. You need to know Python basics, and object-oriented programming (OOP) is a good plus as ROS 2 is heavily using OOP everywhere.
• Optional: C++ programming. Even if the focus of the book is on Python, I still wanted to include C++ code for everything we do. If you only want to learn Python, you can ignore the C++ code, but of course, if you want to follow C++ instructions, you need C++ basics (better with OOP).
I want to emphasize that it will be much, much easier for you to learn ROS 2 if you have good programming and Linux basics. Learning ROS is already quite challenging (though with this book, the goal is to reduce the learning curve), so if you're starting ROS, Linux, and Python from scratch, this could be overwhelming.
If you're reading these lines and you don't know how to write a Python function or navigate to a directory in the Terminal, then I really recommend that you pause here, take some time to learn Python and Linux basics, and come back to this book. There's no need to spend hundreds of hours doing this but investing some time to get the basics right will help you finish this ROS 2 book faster.

Hardware and software
You'll need to have a computer to follow this book. Regarding the specifications, you don't need anything fancy to get started with ROS 2. If you can open a web browser with a few tabs and have a smooth experience, I would say that your computer is good enough to get started.
Then, later, depending on what you want to do with ROS, you might need a better machine (for example, if you want to simulate multiple robots using lots of sensor and image processing). However, it's probably better to wait until you need the extra power to upgrade. For now, the most important thing to do is start learning ROS.
For software requirements, I will give you the necessary installation instructions throughout this book. All the software we will be using is free to use and open source.
We will also use Ubuntu 24.04, in which we will run ROS 2. Having Ubuntu installed is a requirement, but I will give you a recap in Chapter 2.

How to follow this book
The book is divided into three parts, including 14 chapters.
Each chapter can be followed individually, although for one chapter, you need the knowledge from all previous chapters.
If you got this book because you just want to get started from scratch, then it's simple: follow the book in the order it's been written. I have designed it specifically so that you learn the concepts one step at a time without having to think about what directions you should take.
Then, as you progress, feel free to come back to any chapter to clear up doubts. I encourage you to do that. The first time you learn about a concept, you don't necessarily grasp all the subtleties. As you continue with this book and use the concept along with other new concepts, you often have 'epiphany moments', when everything clicks together.
If you already know some ROS 2 basics (or you've already read this book), then feel free to jump to any chapter. If a chapter starts from a code base that we developed in previous chapters, then you will be able to download the code and start from there.
There is a GitHub repository you can use to follow this book: https://github.com/ PacktPublishing/ROS-2-from-Scratch. All the code we'll write is hosted there, so be sure to use this GitHub repository closely while following along. I will explain how to use this repository a bit later in this book.

Summary
In this introductory chapter, we cleared up some of the most common confusion points regarding ROS: its name, what it is and isn't, when to use it, and why. You also learned more about the different ROS versions (ROS 1 and ROS 2), and you learned what kind of prerequisites you need to get started with ROS 2.
You should now have a better understanding of the big picture, and even if everything still seems a bit confusing, don't worry too much-it will all make sense when you use the ROS 2 concepts and code with them.
Now, to be able to use ROS 2, we need to install it. This will be the focus of the next chapter and will help you get your environment 100% ready for ROS 2.



2
Installing and Setting Up ROS 2

Before using ROS 2, we need to install it and set it up. Doing this is not as trivial as just downloading and installing a basic program. There are several ROS 2 versions (called distributions), and we need to choose which one is the most appropriate. We also need to pick an Ubuntu version as ROS and Ubuntu distributions are closely linked.
Once you know which ROS/Ubuntu combination you need, you have to install the corresponding Ubuntu operating system (OS). Although being familiar with Linux is a prerequisite for this book, I will still do a recap on how to install Ubuntu on a virtual machine (VM), just in case, so you won't be lost and can continue with this book.
Then, we will install ROS 2 on Ubuntu, set it up in our environment, and install additional tools that will allow you to have a better development experience.
By the end of this chapter, you will have everything ready on your computer so that you can use ROS 2 and write custom programs.
Even if all the installation steps sound a bit daunting, don't worry-it's not that hard, and it gets easier to do with every new installation. To give you an idea, with a stable internet connection, it takes me about 1 hour to install a fresh version of Ubuntu and 20 minutes to install ROS (most of that time is spent waiting for the installation to finish).
In this chapter, we are going to cover the following topics:
• Which ROS 2 distribution to choose
• Installing the OS (Ubuntu)
• Installing ROS 2
• Setting up the environment for ROS 2
• Extra tools for ROS 2 development

Which ROS 2 distribution to choose
Before you install ROS 2, it's important to know which distribution you need to use. To make that decision, you first need to understand a bit more about what ROS 2 distributions are, and what specificities each one has.

What is a ROS 2 distribution?
ROS 2 is a project in continuous development, constantly receiving new features or improvements to existing ones.
A distribution is simply a freeze in the development at some given point to create a stable release. With this, you can be sure that the core packages for one given distribution will not have any breaking changes. Without distributions, it would be impossible to have a stable system, and you would need to update your code constantly.
Every year, a new ROS 2 distribution is released on May 23. This day corresponds to World Turtle Day. As you will be able to observe, all ROS distributions have a turtle as a logo; there's a mobile robot platform named TurtleBot and even a 2D educational tool named Turtlesim. This is based on a reference to an educational programming language from 1967 named Logo, which included a feature to move some kind of turtle robot on the screen. So, if you were confused about why there are so many turtles everywhere, now you know-and that's the end of this turtle parenthesis.
You can see all ROS 2 distributions on the ROS 2 documentation releases page: https://docs. ros.org/en/rolling/Releases.html.
You will see one new distribution every year in May. As for the order, there is no number; instead, the names are in alphabetical order. The first official release was named Ardent Apalone, then Bouncy Bolson, and so on. In May 2024, ROS Jazzy Jalisco was released. Following this, you can expect to have ROS K in 2025, ROS L in 2026, and so on. The name of a new release is usually announced 1 year in advance.


On top of all the displayed distributions, there is another one that exists in parallel: ROS Rolling. This distribution is a bit special and is the distribution where all new developments are made. To make an analogy with Git and versioned systems, it's just like having a development branch and using this branch to release stable versions once a year. Thus, ROS Rolling is not a stable distribution, and I don't recommend using it for learning or to release a product. This is a distribution you can use if you want to test brand-new features before they are officially released into the next stable distribution-or if you want to contribute to the ROS code. However, if you're reading this book, you're not there yet.
Now that you know what ROS 2 distributions are and how to find them, let's start to look at the differences between them. This will allow us to choose the right one.

LTS and non-LTS distributions
If you look a bit closer, you'll see that some distributions are supported for 5 years, others for 1.5 years (this only applies after 2022). You can see this by comparing the release date with the end-of- life (EOL) date. Currently supported distributions also have a green background on the screen, so you can easily spot them.
When a distribution reaches its EOL date, it just means that it will not receive official support and package updates anymore. This doesn't mean you can't use it (in fact, lots of companies are still using legacy versions from 5 years ago or more), but you won't get any updates.
The first official ROS 2 distribution was ROS Ardent, released in December 2017. After that, the first few distributions were still not quite complete, and the development team preferred to release shorter distributions so that the development could go faster.
ROS Humble was the first Long-Term Support (LTS) release supported for 5 years (2022-2027).
ROS Jazzy is also an LTS version, with official support from 2024 to 2029. From this, you can expect that every 2 years (even number: 2024, 2026, 2028, and so on), a new LTS distribution will be released in May and supported for 5 years.
A few LTS distributions can coexist. In 2026, for example, with the release of the ROS L distribution, you will be able to use ROS Humble and ROS Jazzy as well.
Then, you have non-LTS distributions. Those are released on odd years (2023, 2025, 2027, and so on) and are supported for 1.5 years only. Those distributions are released just so you can have access to new development in a somehow stable release without having to wait for 2 years. However, due to the short lifespan of non-LTS distributions and the fact that they will probably be less stable (and less supported), it is best not to use them if your goal is learning, teaching, or using ROS for a commercial application.
With this, you can see that we can discard half of the distributions and now focus only on the LTS ones that are currently supported. Let's finish this section and choose the distribution that we will use for this book.

How to choose a ROS distribution
What I recommend is to use the latest available LTS distribution. However, I wouldn't necessarily use an LTS distribution just after it's been released because it can still contain some bugs and problems. Also, some of the plugins and other community packages you need might not have been ported yet. Generally, if you want to work with a stable system, it's sometimes best not to stay too close to the new and shiny technology and wait a bit.
For example, ROS Humble was released in May 2022. Right after it was available, I tested it, but to use it in a production environment, I would have had to wait until September or even November, just to be sure everything was working correctly.
So, for this book, we will use ROS Jazzy, which was released in May 2024.


Installing the OS (Ubuntu)
ROS 2 works on three OSs: Ubuntu, Windows, and macOS. Although Ubuntu and Windows get Tier 1 support, macOS has only Tier 3 support, meaning "best effort," not "fully tested." You can learn more about what Tier 1, 2, and 3 mean on the REP 2000, which describes the timeline and target platforms for ROS 2 releases: https://www.ros.org/reps/rep-2000.html.
This means that using macOS for ROS 2 is not necessarily the best choice for learning (if you're an Apple user). We're left with Windows or Ubuntu.
From teaching experience, I saw that even if ROS could work well on Windows, it's not easy to install and use it correctly. Lots of bugs can occur, especially with the 2D and 3D tools. When you're learning ROS, you want a smooth experience, and you want to spend time learning the features, not fixing the configuration.
Hence, the best overall option is to use Ubuntu. If you don't have Ubuntu and are using Windows/ macOS, you can either install Ubuntu natively as a dual boot on your computer or use a VM (there are a few other options, but I won't cover those here).
Now that we have selected ROS Jazzy, and we want to run it on Ubuntu, the question is: on which Ubuntu distribution do we install it?

The relationship between ROS 2 and Ubuntu
If you go to the Jazzy release page (https://docs.ros.org/en/rolling/Releases/ Release-Jazzy-Jalisco.html), you'll see that ROS Jazzy is supported on Ubuntu 24.04 (and not any other previous or future Ubuntu distributions).
There is a close relationship between ROS and Ubuntu distributions. This relationship is quite simple: for every new Ubuntu LTS distribution (every 2 years on an even number), there is a new ROS 2 LTS distribution:
• Ubuntu 22.04: ROS Humble
• Ubuntu 24.04: ROS Jazzy
• Ubuntu 26.04: ROS L
It's important to use the correct combination. Thus, before installing ROS Jazzy, the first thing you must do is make sure you have Ubuntu 24.04 installed on your computer. If you happen to have an older version, I strongly encourage you to upgrade or simply install Ubuntu 24.04 from scratch.


You have probably already installed a Linux OS at some point in your life, but, from experience, I know some people reading this could get a bit lost with the installation. Hence, I will provide additional installation instructions-an overview of dual boot and detailed instructions for VMs. Feel free to skip this and go to the ROS 2 installation section if you already have installed Ubuntu.

Installing Ubuntu 24.04 natively with a dual boot
The best option is to have Ubuntu installed natively on your computer. This will allow you to follow this book and then go further without any problems. I won't provide a complete tutorial on how to do that here; you can easily find lots of free tutorials on the internet.
Here are the high-level important steps you have to follow:
1. Free some space on your disk so that you can create a new partition. I recommend a minimum of 70 GB, more if possible.
2. Download an Ubuntu .iso file from the official Ubuntu website (Ubuntu 24.04 LTS).
3. Flash this image on an SD card or USB key (with a tool such as Balena Etcher).

4. Reboot your computer and choose to boot from the external device.
5. Follow the installation instructions. Important: When asked how you want to install, select
Alongside Windows, for example-don't erase all your disk.
6. Complete the installation. Now, when you boot your computer, you should get a menu where you can select whether you want to start Ubuntu or Windows.
Those are the main steps to follow; you can find all the information you need on the internet.

Installing Ubuntu 24.04 on a VM
If you can't install Ubuntu as a dual boot (due to technical restrictions, lack of admin rights on the computer, or something else), or if you want to get started quickly with not too much effort, just for the sake of learning ROS, then you might wish to use a VM.
A VM is quite easy to set up and is useful for teaching and learning purposes. As an example, when I teach ROS offline in a workshop for beginners, I often provide a VM that contains everything already installed. With that, it's easier for the participants to get started quickly with ROS. Later, when they have more knowledge, they can take the time to set up a proper OS by themselves.


I will now show you how to install Ubuntu 24.04 on a VM so that you can do it even with no prior knowledge of how to create and run a VM.
Step 1 - downloading the Ubuntu .iso file
Download the Ubuntu 24.04 .iso file https://releases.ubuntu.com/noble/. Note that, just like ROS, Ubuntu distributions also have a name. For Ubuntu 24.04, the name is Ubuntu Noble Numbat. We usually only use the first name, so Ubuntu Noble in this case.
Click on 64-bit PC (AMD64) desktop image. The file should be 5 to 6 GB, so make sure you have a good internet connection before downloading it.
Step 2 - installing VirtualBox
You can start Step 2 while the Ubuntu .iso file is being downloaded.
Two popular VM managers have a free version: VMware Workstation and VirtualBox. Both would work, but here, I will focus on VirtualBox as it's slightly easier to use.

Go to the download page of the official VirtualBox website: https://www.virtualbox.org/ wiki/Downloads. Under VirtualBox Platform Packages, select the current OS you are running. If you want to install VirtualBox on Windows, for example, choose Windows hosts.
Download the installer, then install VirtualBox like any other software.
Step 3 - creating a new VM
Once you've installed VirtualBox and downloaded the Ubuntu .iso file, open the VirtualBox software (VirtualBox Manager) and click New. This will open a pop-up window where you can start to configure the new VM:

Figure 2.1 - Starting the VM setup process

Here, we have the following values:
• Name: Name the machine. This can be anything you want, just so you can recognize the machine-for example, Ubuntu 24.04 - book.
• Folder: By default, VirtualBox will create a VirtualBox VMs folder in your user directory, where it will install all the VMs. You can keep this or change it if you want.
• ISO Image: This is where you select the Ubuntu .iso file that you've just downloaded.
• Type: This should be Linux.
• Version: This should be Ubuntu (64-bit).
• Skip Unattended Installation: Make sure you check this box. Leaving this unchecked could be a cause of issues later.

Click Next. Here, you'll need to choose how much CPU and RAM you want to allocate for the machine:


Figure 2.2 - Allocating hardware resources for the VM

This will depend on your computer's configuration.
Here's what I recommend for the RAM allocation (Base Memory on VirtualBox):
• If you have 16 GB or more on your computer, allocate 6 GB (like I did in Figure 2.2) or a bit more; this is going to be enough.
• If you have 8 GB RAM, allocate 4 GB.
• For less than 8 GB, adjust the RAM value (you can set a value now and modify it later in the settings) so that you can start the VM, open VS Code and Firefox with a few tabs, and your machine doesn't slow down too much. If things get too slow, consider using a more powerful machine for learning ROS.
For the CPU allocation, allocate half of your CPUs. So, if your computer has 8 CPUs, set the value to
4. In my setup, I have 4 CPUs and 8 logical processors, so I chose 4 CPUs. Try not to go under 2 as it will be very slow with only 1 CPU. If in doubt, try one setting now; you can change it later.
All in all, it's better to stay in the green zone. If you have to push to the orange zone, then make sure that when you run your VM, you don't run anything else on your computer (or maybe just a web browser with one tab or a PDF reader for this book).

Click Next. The last thing to do for now is to configure the virtual hard disk that will be created for the VM:


Figure 2.3 - Creating a virtual disk for the VM

Here are the settings you must choose for this screen:
1. You can keep the default option (Create a Virtual Hard Disk Now). The default size is 25 GB. To learn ROS 2, I recommend using 30 to 40 GB minimum. Anyway, the size of the VM will start low and expand as you install more things, so you can set a higher maximum without blocking resources.
2. Keep the Pre-allocate Full Size box unchecked.
Click Next. You will now get a recap of all options you chose in the previous steps. Then, click Finish. You will see the newly created VM on the left in VirtualBox Manager.
Before you start the VM, there are a few more things we need to configure. Open the settings for the VM (either select it and click on the Settings button or right-click on the VM and choose Settings).
Modify the following three settings:
• System | Acceleration: Uncheck the Enable Nested Paging box
• Display: Uncheck the Enable 3D Acceleration box (this one may already be unchecked)
• Display: Increase Video Memory to 128 MB if possible

With these settings, you can probably avoid unexpected behaviors and problems with the graphical interface in the VM.


Step 4 - starting the VM and finishing the installation
Now that the VM has been configured correctly, we need to start it to install Ubuntu, using the Ubuntu
.iso file that we've downloaded and added to the settings.
To start the VM, double-click on it in VirtualBox Manager, or select it and click on the Start button.
You will get a boot menu. The first choice is Try or Install Ubuntu and it should already be selected. Press Enter.
Wait a few seconds; Ubuntu will start with the installation screen. Follow the configuration through the different windows:
1. Choose your language. I recommend you keep English so you have the same configuration as me.
2. Skip the Accessibility menu, unless you need to set up a bigger font size, for example.
3. Select your keyboard layout.
4. Connect to the internet. To do so, choose Use wired connection.
5. At this point, you might have a screen asking you to update the installer. In this case, click Update now. Once finished, click Close installer. Look for Install Ubuntu 24.04 LTS on the VM desktop and double-click on it. This will start the installation again from Step 1; repeat Steps 1 to 4.
6. When you're asked how you would like to install Ubuntu, choose Interactive installation.
7. For the applications to install with Ubuntu, go with Default selection. This will reduce the space used by the VM and you still get a web browser, as well as all the core basics-we don't need more than that to install ROS 2.
8. When asked if you want to install recommended proprietary software, choose Install third- party software for graphics and Wi-Fi hardware.
9. For the disk setup, select Erase disk and install Ubuntu. There's no risk here as we're erasing the empty virtual disk we've just created (if you were installing Ubuntu as a dual boot, you would have to choose another option).

10. Choose a username, computer name, and password. Keep things simple here. For example, I use ed for the user and ed-vm for the computer's name. Also, make sure that the password is typed correctly, especially if you've changed the keyboard layout previously.
11. Select your time zone.
12. On the recap menu, click Install and wait a few minutes.
13. When the installation is complete, a popup will ask you to restart. Click Restart now.
14. You will see a message stating Please remove the installation medium, then press ENTER. There's no need to do anything here-just press Enter.
15. After booting, you will get another welcome screen popup. You can skip all the steps and click
Finish to exit the popup.
With that, Ubuntu has been installed.
Just to finish things properly, open a Terminal window and upgrade the existing packages (it's not because you just installed Ubuntu that all packages are up to date):

That's it for the installation. However, there's one more thing specific to VirtualBox that we must do so that the VM window works correctly.
Step 5 - Guest Additions CD Image
At this point, if you try to resize the window where the VM is running, you will see that the desktop resolution doesn't change. Also, if you try to copy/paste some text or code between your host and the VM, it probably won't work.
To fix this, we need to install what's called the Guest Additions CD Image.
First, open a Terminal and run the following command (note that copy/paste doesn't work yet, so you have to type it manually). This will install a few dependencies, all of which are required for the next step:

Then, on the top menu of the VM window, click Devices | Insert Guest Additions CD image.
You will see a new CD image on the Ubuntu menu (on the left). Click on it-this will open a file manager. Inside the file manager, right-click on the empty space and choose Open in Terminal. See the following figure for more clarification:



Figure 2.4 - Opening the Guest Additions CD Image folder in the Terminal

You will then be inside a Terminal, where you can find a file named VBoxLinuxAdditions.run. You need to run this file with admin privileges:

After this, you might get a popup asking you to reboot the VM. Click Restart Now. If you don't get this popup, simply run sudo reboot in the Terminal.
When the VM starts again, the screen should resize automatically when you change the size of the window. If it doesn't work the first time, I found that running the command once again (sudo ./ VBoxLinuxAdditions.run) and rebooting may solve the problem.
You can then right-click on the disk and choose Eject, and you're all set. To enable copy/paste between the host and the VM, go to the top menu and click Devices | Shared Clipboard | Bidirectional.
Now, your VM is fully installed and configured. If you've chosen that path, this will allow you to complete at least Part 1 and Part 2 of this book. For Part 3, as mentioned previously, you might encounter some issues, especially when using Gazebo. When you reach this point, I suggest that you install Ubuntu natively with a dual boot.

Installing ROS 2 on Ubuntu
Now that you have Ubuntu 24.04 installed on your computer (either as a dual boot or in a VM), let's install ROS 2. As discussed previously, we will install ROS Jazzy here. If you're using a different Ubuntu distribution, make sure to use the appropriate ROS 2 distribution.
The best way to install ROS 2 is to follow the instructions on the official documentation website, for binary packages installation: https://docs.ros.org/en/jazzy/Installation/ Ubuntu-Install-Debians.html. There are quite a few commands to run, but don't worry- all you need to do is copy and paste them one by one.


Now, let's start the ROS 2 installation.

Setting the locale
Make sure you have a locale that supports UTF-8:

With this, you can check that you have UTF-8. If in doubt, just run those commands one by one (I do this every time):

Now, check again; you'll see UTF-8 this time:


Setting up the sources
Run those five commands one by one (note that it's better to copy/paste them from the official documentation directly):




The main goal of these commands is to add the ROS packages server to your apt sources. Run the following command:

You should now see additional lines, something like this:

Those new sources (packages.ros.org) will allow you to fetch the ROS 2 packages when installing with apt. Here, you can also see noble, which means the ROS 2 packages are for Ubuntu Noble (24.04). Since you know how Ubuntu and ROS distributions are linked, this also means ROS Jazzy.
Now that we have the correct sources, we can finally install ROS 2.

Installing ROS 2 packages
As a best practice, upgrade all your existing packages before you install any ROS 2 packages:

Now, you can install ROS 2 packages. As shown in the documentation, you can choose between
Desktop Install or ROS-Base Install.
ROS 2 is not just one piece of software or package. It's a collection of many packages:
• ROS-Base: This contains the bare minimum packages to make ROS 2 work correctly
• ROS Desktop: This contains all the packages in ROS-Base, plus lots of additional packages, so you get access to more tools, simulations, demos, and so on
Since you're installing ROS 2 on a computer with a desktop, and you want to have access to as many functionalities as you can, choose ROS Desktop Install. If you were to install ROS on a limited environment, such as Ubuntu Server (no desktop) on a Raspberry Pi board, then ROS-Base would make sense.

Install ROS Desktop by running the following command:

Replace <distro> with the distribution name (using lowercase). So, if you want to install ROS Jazzy, you will use the following command:

As you can see, when you run this command, a few hundred new packages will be installed. This can take some time, depending on your internet connection speed, as well as the performance of your computer (or VM).
If you see an error stating unable to locate package ros-jazzy-desktop, for example, it probably means you're trying to install a ROS 2 distribution on the wrong Ubuntu version. This is a common error, so make sure to use the correct Ubuntu/ROS 2 pairing (as seen previously in this chapter).

Once the installation is done, you can also install the ROS development tools. We'll need these in the remainder of this book to compile our code and create ROS programs. For this command, no ROS distribution needs to be specified; it's the same for all of them:

Once you've done this, ROS 2 will be installed, and you'll have all the ROS 2 tools you need.
I also recommend that you frequently update the ROS 2 packages you've installed. To do so, simply run sudo apt update and sudo apt upgrade, like you would update any other package.

Setting up the environment for ROS 2
At this point, open a Terminal and run the following command:

You will get an error message saying that the ros2 command can't be found. As we will see later, ros2 is a command-line tool we can use to run and test our programs from the Terminal. If this command isn't working, it means that ROS 2 hasn't been set up correctly.

Even if ROS 2 is installed, there's one more thing you need to do in every new session (or Terminal) where you want to use ROS 2: you need to source it in the environment.

Sourcing ROS 2 in the environment
To do that, source this bash script from where ROS 2 is installed:

Replace <distro> with the current distribution name you are using. For ROS Jazzy, run the following command:

After you run this, try executing the ros2 command again. This time, you should get a different message (usage message). This means that ROS 2 is correctly installed and set up in your environment.


Adding the source line to the .bashrc file
You must source this bash script every time you open a new session or Terminal. To make things easier and so you don't forget about it, let's just add this command line to the .bashrc file.
If you don't know what .bashrc is, simply put, it's a bash script that will run every time you open a new session (that can be an SSH session, a new Terminal window, and so on). This .bashrc file is specific to each user, so you will find it in your home directory (as a hidden file because of the leading dot).
You can add the source line to the .bashrc file with this command:

Replace <distro> with your ROS distribution name. You could also just open the .bashrc file directly with any text editor-gedit, nano, or Vim-and add the source line at the end. Make sure it's only added once.
Once you've done this, any time you open a new Terminal, you can be sure that this Terminal is correctly sourced, and thus you can use ROS 2 in it.

Now, to make a final check, open a Terminal and run this command (there's no need to understand anything for now; it's just to verify the installation):

This will print a few logs, and you should see a new window with a turtle in the middle. To stop the program, press Ctrl + C in the Terminal where you ran the command.
That's it for installing and configuring ROS 2. I will just give you a few more tips on what development tools can be useful when developing with ROS.

Extra tools for ROS development
Apart from the mandatory previous steps to install and set up ROS 2, any other development tool is up to you. If you have your favorite way of working with a Terminal, your favorite text editor, or your favorite integrated development environment (IDE), this is perfectly fine.
In this section, I will show you a few tools that lots of ROS developers use (me included) and that I think can help you get a better experience when developing with ROS.

Visual Studio Code
Visual Studio Code (VS Code) is a quite popular IDE used by many developers. What makes it nice for us is its good support for ROS development.
VS Code is free to use and open source; you can even find its code on GitHub. To install VS Code, open a Terminal and run the following command:

The installation just requires one line and uses Ubuntu's Snap feature. After installing it, you can open VS Code by searching for it in the Ubuntu applications, or simply by running code in the Terminal.
Now, start VS Code and go to the Extensions panel-you can find it on the left menu.
There, you can search for the ROS extension by typing ros. There are quite a few; choose the one developed by Microsoft. This extension is compatible with both ROS 1 and ROS 2, so there's no problem here:




Figure 2.5 - The ROS extension to install in VS Code

Install this extension. This will also install a bunch of other extensions, notably Python and C++ extensions, which are quite useful when writing code.
On top of this, I also usually install the CMake extension by twxs (just type cmake and you'll find it). With this, we get nice syntax highlighting when writing into CMakeLists.txt files, which is something we will have to do quite often with ROS 2.

The Terminal and other tools
As you develop with ROS 2, you will often need to open several Terminals: one for compiling and installing, a few to run the different programs of your application, and a few more for introspection and debugging.
It can become quite difficult to keep track of all the Terminals you use, so as best practice, it's nice to have a tool that can easily handle multiple Terminals in one window.
There are quite a few tools for doing this. The one I'm going to talk about here is called terminator. Not only does it have a funny name, but it's also super practical to use.
To install terminator, run the following command:

Then, you can find it from the applications menu, run it, right-click on the left bar menu, and choose
Pin to Dash so that it stays there and becomes easy to start.

You can find all the commands for terminator online, but here are the most important ones to get started:
• Ctrl + Shift + O: split the selected Terminal horizontally.
• Ctrl + Shift + E: split the selected Terminal vertically.
• Ctrl + Shift + X: make the current Terminal fill the entire window. Use again to revert.
• Ctrl + Shift + W: close a Terminal.

Figure 2.6 - Terminator with four Terminals

Whenever you split a Terminal, this Terminal becomes two different Terminals, each being one session. Thus, you can easily split your Terminal into four or six; this will be enough to run most of your ROS 2 applications. Since we previously added the line to source ROS 2 in the .bashrc file, you can use ROS 2 directly in each new Terminal.
Summary
When choosing a ROS 2 distribution, I recommend that you pick the latest LTS distribution, given that it's a few months old and contains all the functionalities you need.
To install and set up ROS 2, you first need to have Ubuntu installed. Each ROS 2 distribution is linked to a specific Ubuntu distribution.

For ROS 2 Jazzy, you must install Ubuntu 24.04. The best option is to have it natively with a dual boot, but to get started quickly, you can also choose to install it in a VM. Then, you can install the ROS 2 packages.
After this, it's important to source the environment for ROS 2 by sourcing a bash script from the ROS installation folder. You can add the line to source this script into your .bashrc file so that you don't need to do this every time you open a new Terminal.
Finally, to get a better development experience with ROS, I suggest using VS Code with the ROS extension, and a tool that allows you to split the Terminal into multiple Terminals, such as terminator.
With this setup, you are fully ready to start using ROS 2. In the next chapter, you will run your first ROS 2 programs and discover the core concepts.



4
Writing and Building
a ROS 2 Node

To write your own custom code with ROS 2, you will have to create ROS 2 programs, or in other words, nodes. You already discovered the concept of nodes in Chapter 3. In this chapter, we will go deeper, and you will write your first node with Python and C++.
Before you create a node, there is a bit of setup to do: you need to create a ROS 2 workspace, in which you will build your application. In this workspace, you will then add packages to better organize your nodes. Then, in those packages, you can start to write your nodes. After you write a node, you will build it and run it.
We will do this complete process together, with hands-on code and command lines all along the way. This is the process that you will repeat for any new node you create when developing a ROS 2 application.
By the end of this chapter, you will be able to create your own packages and ROS 2 nodes with Python and C++. You will also be able to run and introspect your nodes from the terminal. This is the stepping stone you need in order to learn any other ROS 2 functionality. There is no topic, service, action, parameter, or launch file without nodes.
All explanations will start with Python, followed by C++, which we'll cover more quickly. If you only want to learn with Python, you can skip the C++ sections. However, if you want to learn with C++, reading the previous Python explanations is mandatory for comprehension.
All the code examples for this chapter can be found in the ch4 folder of the book's GitHub repository (https://github.com/PacktPublishing/ROS-2-from-Scratch).
In this chapter, we will cover the following topics:
• Creating and setting up a ROS 2 workspace
• Creating a package

• Creating a Python node
• Creating a C++ node
• Node template for Python and C++ nodes
• Introspecting your nodes

Technical requirements
To follow this chapter, you need the following:
• Ubuntu 24.04 installed (dual boot or virtual machine)
• ROS Jazzy
   • A text editor or IDE (for example, VS Code with the ROS extension) These requirements will be valid for all chapters in Part 2.
Creating and setting up a ROS 2 workspace
Before we write any code, we need to do a bit of organization. Nodes will exist within packages, and all your packages will exist within a ROS 2 workspace.
What is a ROS 2 workspace? A workspace is nothing more than a folder organization in which you will create and build your packages. Your entire ROS 2 application will live within this workspace.
To create one, you have to follow certain rules. Let's create your first workspace step by step and correctly set it up.

Creating a workspace
To create a workspace, you will simply create a new directory inside your home directory.
As for the workspace's name, let's keep it simple for now and use something that is recognizable: ros2_ws.


Open a terminal, navigate to your home directory, and create the workspace:

Then, enter the workspace and create a new directory named src. This is where you will write all the code for your ROS 2 application:

That's really all there is to it. To set up a new workspace, you just create a new directory (somewhere in your home directory) and create an src directory inside it.

Building the workspace
Even if the workspace is empty (we have not created any packages yet), we can still build it. To do that, follow these steps:
1. Navigate to the workspace root directory. Make sure you are in the right place.
2. Run the colcon build command. colcon is the build system in ROS 2, and it was installed when you installed the ros-dev-tools packages in Chapter 2.
Let's build the workspace:

As you can see, no packages were built, but let's list all directories under ~/ros2_ws:

As you can see, we have three new directories: build, install, and log. The build directory will contain the intermediate files required for the overall build. In log, you will find logs for each build. The most important directory for you is install, which is where all your nodes will be installed after you build the workspace.


Sourcing the workspace
If you navigate inside the newly created install directory, you can see a setup.bash file:

$ cd install/$ lsCOLCON_IGNORE_local_setup_util_ps1.pysetup.ps1local_setup.bash_local_setup_util_sh.pysetup.shlocal_setup.ps1local_setup.zshsetup.zshlocal_setup.shsetup.bashThis might look familiar. If you remember, after we installed ROS 2, we sourced a similar bash script from the ROS 2 installation directory (/opt/ros/jazzy/setup.bash) so that we could use ROS 2 in our environment. We will need to do the same for our workspace.
Every time you build your workspace, you have to source it so that the environment (the session you are in) knows about the new changes in the workspace.
To source the workspace, source this setup.bash script:

Then, as we previously did, we are going to add that line into our .bashrc. This way, you don't need to source the workspace every time you open a new terminal.
Open your .bashrc (located in your home directory the path is ~/.bashrc) using any text editor you want:

Add the line to source the workspace's setup.bash script, just after the one to source the global ROS 2 installation. The order is very important here. You have to source the global ROS 2 installation first, and then your workspace, not the other way around:

Make sure to save.bashrc. Now, both ROS 2 and your workspace will be sourced in any new terminal you open.


Your workspace is now correctly set up, and you can build your application. Next step: creating a package.

Creating a package
Any node you create will exist within a package. Hence, to create a node, you first have to create a package (inside your workspace). You will now learn how to create your own packages, and we will see the differences between Python and C++ packages.
But first, what exactly is a package?

What is a ROS 2 package?
A ROS 2 package is a sub-part of your application.
Let's consider a robotic arm that we want to use to pick up and place objects. Before we create any node, we can try to split this application into several sub-parts, or packages.
We could have one package to handle a camera, another package for the hardware control (motors), and yet another package to compute motion planning for the robot.


Figure 4.1 - Example of a package organization for a robot

Each package is an independent unit, responsible for one sub-part of your application.
Packages are very useful for organizing your nodes, and also to correctly handle dependencies, as we will see later in this book.
Now, let's create a package, and here you have to make a choice. If you want to create a node with Python, you will create a Python package, and if you want to create a node with C++, you will create a C++ package. The architecture for each package type is quite different.

Creating a Python package
You will create all your packages in the src directory of your ROS 2 workspace. So, make sure to navigate to this directory before you do anything else:

Here is how to construct the command to create a package:
1. ros2 pkg create <pkg_name>: This is the minimum you need to write.
2. You can specify a build type with --build_type <build_type>. For a Python package, we need to use ament_python.
3. You can also specify some optional dependencies with --dependencies <list_of_ dependencies_separated_with_spaces>. It's always possible to add dependencies later in the package.
Let's create our first package named my_py_pkg. We will use this name as an example to work with the main ROS 2 concepts. Then, as we progress, we will use more meaningful names. In the src directory of your workspace, run the following:

With this command, we say that we want to create a package named my_py_pkg, with the ament_ python build type, and we specify one dependency: rclpy-this is the Python library for ROS 2 that you will use in every Python node.
This will print quite a few logs, showing you what files have been created. You might also get a [WARNING] log about a missing license, but as we have no intention of publishing this package anywhere, we don't need a license file now. You can ignore this warning.
You can then see that there is a new directory named my_py_pkg. Here is the architecture of your newly created Python package:


Not all the files are important right now. We'll see how to use those files to configure and install our nodes just a bit later.
Here is a quick overview of the most important files and directories:
• my_py_pkg: As you can see, inside the package, there is another directory with the same name. This directory already contains an  init .py file. This is where we will create our Python nodes.
• package.xml: Every ROS 2 package (Python or C++) must contain this file. We will use it to provide more information about the package as well as dependencies.
• setup.py: This is where you will write the instructions to build and install your Python nodes.

Creating a C++ package
We will work a lot with Python in this book, but for completeness, I will also include C++ code for all examples. They will either be explained in the book, or the code will be in the GitHub repository.
Creating a C++ package is very similar to creating a Python package; however, the architecture of the package will be quite different.
Make sure you navigate to the src directory of your workspace, and then create a new package. Let's use a similar pattern as we did for Python and name the package my_cpp_pkg:

We choose ament_cmake for the build type (meaning this will be a C++ package), and we specify one dependency: rclcpp-this is the C++ library for ROS 2, which we will use in every C++ node.
Once again, you should see quite a few logs, with the newly created files, and maybe a warning about the license that you can ignore.
The architecture of your new C++ package will look like this:


Here is a quick explanation of the role of each file or directory:
• CMakeLists.txt: This will be used to provide instructions on how to compile your C++ nodes, create libraries, and so on.
• include directory: In a C++ project, you may split your code into implementation files (.cpp extension) and header files (.hpp extension). If you split your C++ nodes into .cpp and .hpp files, you will put the header files inside the include directory.
• package.xml: This file is required for any kind of ROS 2 package. It contains more information about the package, and dependencies on other packages.
• src directory: This is where you will write your C++ nodes (.cpp files).

Building a package
Now that you've created one or more packages, you can build them, even if you don't have any nodes in the packages yet.
To build the packages, go back to the root of your ROS 2 workspace and run colcon build. Once again, and as seen previously in this chapter, where you run this command is very important.

Both packages have been built. You will have to do that every time you add or modify a node inside a package.
The important thing to notice is this line: Finished <<< <package_name> [time]. This means that the package was correctly built. Even if you see additional warning logs, if you also see the Finished line, you know the package has been built.


To build only a specific package, you can use the --packages-select option, followed by the name of the package. Here's an example:

This way, you don't need to build your entire application every time and can just focus on one package.
Now that we have created some packages and we know how to build them, we can create nodes in the packages. But how are we going to organize them?

How are nodes organized in a package?
To develop a ROS 2 application, you will write code inside nodes. As seen in Chapter 3, node is simply the name of a ROS 2 program.
A node is a subprogram of your application, responsible for one thing. If you have two different functionalities to implement, then you will have two nodes. Nodes communicate with each other using ROS 2 communications (topics, services, and actions).
You will organize your nodes inside packages. For one package (sub-part of your application), you can have several nodes (functionalities). To fully understand how to organize packages and nodes, you need practice and experience. For now, let's just get an idea with an example.
Let's come back to the package architecture we had in Figure 4.1, and add nodes inside the packages:


Figure 4.2 - Example of a package organization with nodes

As you can see, in the camera package, we could have one node responsible for handling the camera hardware. This node would send images to an image processing node, and this latter would extract the coordinates of objects for the robot to pick up.
In the meantime, a motion planning node (in the motion planning package) would compute the movements that the robot should perform, given a specific command. A path correction node can support this motion planning using the data received from the image processing node.
Finally, to make the robot move, a hardware driver node would be responsible for hardware communication (motors, encoders) and receive commands from the motion planning node. An additional state publisher node could be here to publish additional data about the robot for other nodes to use.
This node organization is purely fictitious and is here just to give you a general idea of how a ROS 2 application can be designed, and which roles a node can have in this application.
Now, you are (finally) going to write your first ROS 2 node. ROS 2 requires quite a lot of installation and configuration before you can actually write some code, but good news, we have completed all of this and can now focus on the code.
We won't do anything too complicated for now; we won't dive into complex features or communications. We will write a basic node that you can use as a template to start any future node. We will also build the node and see how to run it.
Creating a Python node
Let's create our first Python node, or in other words, our first ROS 2 Python program.
The processes of creating Python and C++ nodes are very different. That's why I have written a separate section for each of them. We will start with Python, with complete step-by-step explanations. Then we will see how to do the same with C++. If you want to follow the C++ node section, make sure to read this one first.
To create a node, you will have to do the following:
1. Create a file for the node.
2. Write the node. We will use Object Oriented Programming (OOP), as officially recommended for ROS 2 (and almost every existing ROS 2 code you find uses OOP).
3. Build the package in which the node exists.
4. Run the node to test it.
Let's get started with our first Python node.

Creating a file for the node
To write a node, we first need to create a file. Where should we create this file?
If you remember, when we created the my_py_pkg package, another my_py_pkg directory was created inside the package. This is where we will write the node. For every Python package, you have to go to the directory which has the same name as the package. If your package name is abc, then you'll go to ~/ros2_ws/src/abc/abc/.
Create a new file in this directory and make it executable:

After this, open this file to write in it. You can use any text editor or IDE you want here, as long as you don't get lost in all the files.
If you have no idea what to use, I suggest using VS Code with the ROS extension (as explained in
Chapter 2). This is the tool I'm using for all ROS development.


Writing a minimal ROS 2 Python node
Here is the starting code for any Python node you will create. You can write this code into the
my_first_node.py file:




As you can see, we use OOP here. OOP is everywhere in ROS 2, and this is the default (and recommended) way to write a node.
Let's come back to this code step by step, to understand what it's doing:

We first import rclpy, the Python library for ROS 2. Inside this library, we can get the Node class. We then create a new class that inherits from the rclpy Node class:

In this class, make sure you call the parent constructor with super(). This is also where you will specify the node name.
This node is not doing anything for now; we will add a few functionalities in a minute. Let's finish the code:

After the class, we create a main() function in which we perform the following actions:
1. Initialize ROS 2 communications with rclpy.init(). This should be the first line in your main()function.
2. Create an object from the MyCustomNode class we wrote before. This will initialize the node. There's no need to destroy the node later, as this will happen automatically when the program exits.
3. Make the node spin. If you omit this line, the node will be created, then the program will exit, and the node will be destroyed. Making the node spin means that we block the execution here, the program stays alive, and thus the node stays alive. In the meantime, as we will see shortly, all registered callbacks for the node can be processed. When you press Ctrl + C, the node will stop spinning and this function will return.

4. After the node is killed, shut down ROS 2 communications with rclpy.shutdown(). This will be the last line of your main()function.
This is how all your ROS 2 programs will work. As you can see, the node is in fact an object that we create within the program (the node is not the program in itself, but still, it is quite common to refer to the word "node" when we talk about the program). After being created, the node can stay alive and play its part while it is spinning. We will come back to this spinning shortly.
Finally, we also have added these two lines:

This is a pure Python thing and has nothing to do with ROS 2. It just means that if you run the Python script directly, the main() function will be called, so you can try your program without having to install it with colcon.
Great, you have written your first minimal Python node. Before you build and run it, add one more line in the Node's constructor, so it can do something:

This line will print Hello World when the node starts.
As the MyCustomNode class inherits from the Node class, we get access to all the ROS 2 functionalities for nodes. This will make things quite convenient for us. Here, you have an example with the logging functionality: we get the get_logger() method from Node. Then, with the info()method, we can print a log with the info level.

Building the node
You are now going to build the node so that you can run it.
You might think: why do we need to build a Python node? Python is an interpreted language; couldn't we just run the file itself?
Yes, this is true: you could test the code just by running it in the terminal ($ python3 my_first_ node.py). However, what we want to do is actually install the file in our workspace, so we can start the node with ros2 run, and later on, from a launch file.
We usually use the word "build", because to install a Python node, we have to run colcon build.

To build (install) the node, we need to do one more thing in the package. Open the setup.py file from the my_py_pkg package. Locate entry_points and 'console_scripts' at the end of the file. For each node we want to build, we have to add one line inside the 'console_scripts' array:

Here is the syntax:

There are a few important things to correctly write this line:
• First, choose an executable name. This will be the name you use with ros2 run <pkg_name>
<executable_name>.
• For the filename, skip the .py extension.
• The function name is main, as we have created a main() function in the code.
• If you want to add another executable for another node, don't forget to add a comma between each executable and place one executable per line.

Now that you have given the instructions to create a new executable, go to your workspace root directory and build the package:


You can also add --packages-select my_py_pkg to only build this package.
The executable should now be created and installed in the workspace (it will be placed inside the
install directory). We can say that your Python node has been built, or installed.

Running the node
Now you can run your first node, but just before that, make sure that the workspace is sourced in your environment:

This file already contains the line to source the workspace; you could also just open a new terminal, or source the setup.bash script from the workspace.
You can now run your node using ros2 run (if you have any doubts, go back to the experiments we did in Chapter 3):

Great, we see the log Hello World. Your first node is successfully running. Note that we wrote
test_node in the ros2 run command, as it's the executable name we chose in the setup.py file.
Now, you might notice that the program is hanging there. The node is still alive because it is spinning. To stop the node, press Ctrl + C.

Improving the node - timer and callback
At this point, you might feel that writing, building, and running a node is a long and complicated process. It's actually not that complex, and it gets easier with each new node that you create. On top of that, modifying an existing node is even easier. Let's see that now.
The node we ran is very basic. Let's add one more functionality and do something more interesting.
Our node is printing one piece of text when it's started. We now want to make the node print a string every second, as long as it's alive.
This behavior of "doing X action every Y seconds" is very common in robotics. For example, you could have a node that "reads a temperature every 2 seconds", or that "gives a new motor command every 0.1 seconds".
How to do that? We will add a timer to our node. A timer will trigger a callback function at a specified rate.

Let's go back to the code and modify the MyCustomNode class. The rest of the code stays the same:

We still have the constructor with super(), but now the log is in a separate method. Also, instead of just printing Hello World, here we create a counter_ attribute that we increment every time we use the log.


The most important line is the one to create the timer. To create the timer we use the create_ timer() method from the Node class. We need to give two arguments: the rate at which we want to call the function (float number), and the callback function. Note that the callback function should be specified without any parenthesis.
This instruction means that we want to call the print_hello method every 1.0 second.
Let's now try the code. As we have already specified how to create an executable from this file in the
setup.py file, we don't need to do it again.
All we have to do is to build, source, and run. Remember: "build, source, run." Every time you create a new node, or modify an existing one, you have to "build, source, run."
In a terminal, go to the root directory of your ROS 2 workspace and build the package:



Then, from this terminal or another one, source and run the following:

As you can see, the process of build, source, and run is quite fast and not that complicated. Here, we can see that the node prints a log every second, and the counter increments in each new log.
Now, how is this possible? How is the print_hello() method called? We have created a timer, yes, but nowhere in the code have we actually called print_hello() directly.
It works because the node is spinning, thanks to rclpy.spin(node). This means that the node is kept alive, and all registered callbacks can be called during this time. What we do with create_ timer() is simply to register a callback, which can then be called when the node is spinning.
This was your first example of a callback, and as you will see in the following chapters of the book, everything runs with callbacks in ROS 2. At this point, if you still have some trouble with the syntax, the callbacks, and the spinning, don't worry too much. As you make progress with the book, you will repeat this process many times. When learning ROS 2, understanding comes with hands-on experience.
We are now done with this Python node. With what you've seen here, you should be able to create your own new Python nodes (in the same package or another package). Let's now switch to C++. If you are only interested in learning ROS 2 with Python for now, you can skip the C++ section.

Creating a C++ node
We are going to do exactly the same thing we did for the Python node: create a file, write the node, build, source, and run.

Make sure you have read the previous Python section as I will not repeat everything here. We will basically just see how to apply the process for a C++ node.
To create a C++ node, we first need a C++ package. We will use the my_cpp_pkg package that we created previously.

Writing a C++ node
Let's create a file for the node. Go to the src directory inside the my_cpp_pkg package and create a .cpp file:

You could also create the file directly from your IDE and not use the terminal.
Now, if you haven't done this previously, open your workspace with VS Code or any other IDE:

Open my_first_node.cpp. Here is the minimal code to write a C++ node:



As you can see (and this was similar with Python), in ROS 2 we heavily use OOP with C++ nodes. Let's analyze this code step by step:
We first include rclcpp, the C++ library for ROS 2. This library contains the rclcpp::Node class:

As we did for Python, we have created a class that inherits from the Node class. The syntax is different, but the principle is the same. From this Node class, we will be able to access all the ROS 2 functionalities: logger, timer, and so on. As you can see, we also specify the node name in the constructor. For now, the node does nothing; we will add more functionalities in a minute:

You need a main() function if you want to be able to run your C++ program. In this function, we do exactly the same thing as for Python, with just some differences in the syntax:
1. Initialize ROS 2 communications with rclcpp::init().
2. Create a node object from your newly written class. As you can see, we don't create an object directly, but a shared pointer to that object. In ROS 2 and C++, almost everything you create will be a smart pointer (shared, unique, and so on).

3. We then make the node spin with rclcpp::spin().
4. Finally, when the node is stopped (Ctrl + C), we shut down all ROS 2 communications with rclcpp::shutdown().
This structure for the main() function will be very similar for all your ROS 2 programs. As you can see, once again, the node is not the program in itself. The node is created inside the program.
Before we go further and build, source, and run our node, let's improve it now with a timer, a callback, and a log.
Modify the MyCustomNode class, and leave the rest as it is:

This code example will do the same thing as for the Python node. We create a timer so that we can call a callback function every 1.0 second. In this callback function, we print Hello followed by a counter that we increment every time.
There are some specificities related to C++:
• For the timer, we have to create a class attribute. As you can see we also create a shared pointer here: rclcpp::TimerBase::SharedPtr.
• We use this->create_wall_timer() to create the timer. this-> is not required here, but I have added it to emphasize that we are using the create_wall_timer() method from the Node class.
• To specify the callback in the timer, as we are in a C++ class, we have to use std::bind(&ClassName::method_name, this). Make sure you don't use any parenthesis for the method name.

The node is now finished, so we can build it.

Building and running the node
We can't just run the C++ file; we first have to compile it and create an executable. To do this, we will edit the CMakeLists.txt file. Open this file, and after a few lines, you will find something like this:

The line to find rclcpp is here because we provided --dependencies rclcpp when we created the package with ros2 pkg create. Later on, if your nodes in this package require more dependencies, you can add the dependencies here, one per line.
Just after this line, add an extra new line, and then the following instructions:

To build a C++ node, we need to do three things:
1. Add a new executable with the add_executable()function. Here, you have to choose a name for the executable (the one that will be used with ros2 run <pkg_name>
<executable_name>), and we also have to specify the relative path to the C++ file.
2. Link all dependencies for this executable with the ament_target_dependencies()function.
3. Install the executable with the install()instruction, so that we can find it when we use
ros2 run. Here, we put the executable in a lib/<package_name> directory.
Then, for each new executable you create, you need to repeat steps 1 and 2 and add the executable inside the install() instruction, one per line without any commas. There's no need to create a new install() instruction for each executable.


You can now build the package with colcon build, which is going to create and install the executable:

If you get any error during the build process, make sure to fix your code first, and then build again. Then, you can source your environment, and run your executable:


[INFO][1711006463.017149024][my_node_name]:Hello0[INFO][1711006464.018055674][my_node_name]:Hello1[INFO][1711006465.015927319][my_node_name]:Hello2[INFO][1711006466.015355747][my_node_name]:Hello3As you can see, we run the test_node executable (built from my_first_node.cpp file), which is going to start the my_node_name node.
You have now successfully written a C++ node. For each new node that you create, you will have to create a new C++ file, write the node class, set the build instructions for a new executable in CMakeLists.txt, and build the package. Then, to start the node, source the environment and run the executable with ros2 run.

Node template for Python and C++ nodes
All the nodes we start in this book will follow the same structure. As additional help to get started quickly, I have created a node template you can use to write the base of any Python or C++ node. I use these templates myself when creating new nodes, as the code can be quite repetitive.
You can copy and paste the templates either from this book directly, or download them from the GitHub repository: https://github.com/PacktPublishing/ROS-2-from-Scratch.

Template for a Python node
Use this code to start any new Python node:




All you have to do is remove the MODIFY NAME comments and change the class name (MyCustomNode) and the node name ("node_name"). It's better to use names that make sense. For example, if you are writing a node to read data from a temperature sensor, you could name the class TemperatureSensorNode, and the node could be temperature_sensor.

Template for a C++ node
Use this code to start any new C++ node:

Remove the MODIFY NAME comments and rename the class and the node.
Those two templates will allow you to start your nodes more quickly. I recommend you to use them as much as you can.

Introspecting your nodes
To finish this chapter, we will practice a bit more with the ros2 node command line.
So far, you have seen how to write a node, build it, and run it. One missing part is to know how to introspect your nodes. Even if a node can run, it doesn't mean it will do exactly what you want it to do.
Being able to introspect your nodes will help you fix errors that you might have made in your code. It will also allow you to easily find more information about other nodes that you are starting but didn't write (as we did in the discovery phase in Chapter 3).
For each core concept in Part 2, we will take a bit of time to experiment with the command-line tools related to the concept. The command-line tool for nodes is ros2 node.
First, and before we use ros2 node, we have to start a node. As a recap, to start a node, we use ros2 run <package_name> <executable_name>. If we start the Python node we have created in this chapter, we use this:

Only after we have started a node can we do some introspection with ros2 node.

ros2 node command line
To list all running nodes, use ros2 node list:

We find the name of the node, which we defined in the code.
Once we have the node name, we can get more info about it with ros2 node info <node_name>:




As you can see, there are quite a lot of things on the terminal. We will get to know all of them in the following chapters. With ros2 node info <node_name> you can see all topics (publishers/ subscribers), services, and actions running for this node.

Changing the node name at run time
As we progress throughout the book, I will give you additional tips for working with ROS 2 and the command line. Here is one: when starting an executable, you can choose to use the default node name (the one defined in the code) or replace it with a new name.
To add any additional argument to ros2 run, first add --ros-args (only once).
Then, to rename the node, add -r   node:=<new_name>. -r means remap; you could also use
--remap. For example, if we want to name the node abc, we could use this:

As you can see from the logs, instead of my_node_name, we see abc. List all running nodes:

This functionality can be very helpful and gives you more control over how to start a node, without having to modify the code directly.


Summary
In this chapter, you have created your first node. Let's do a quick recap of all the steps. Before creating any node, you need to follow these steps:
1. You first need to create and set up a ROS 2 workspace.
2. In this workspace, you can create several packages (Python or C++) that represent different sub-parts of your application.
Then, in one package you can create one or several nodes. For each node, you will have to do the following:
1. Create a file inside the package.
2. Write the node (using the OOP template as a base).
3. Set the build instructions (setup.py for Python, CMakeLists.txt for C++).
4. Build the package.
To run the node, don't forget to source the workspace first, and then start the node with ros2 run
<pkg_name> <executable_name>.
Finally, you can introspect your nodes and even change their names when you start them, using the
ros2 node command line.
Feel free to come back to this chapter anytime to see the complete process of creating a node for both Python and C++. All the code is available on GitHub at https://github.com/ PacktPublishing/ROS-2-from-Scratch. There you can find the OOP template code for Python and C++, my_py_pkg package, and my_cpp_pkg package.
In this chapter, you have also seen how to create a timer and a callback function. You have a better idea of how the spin mechanism works, and how it allows the node to stay alive and run the callbacks. This will be very useful for the following chapters.
In the next chapter, we will see how nodes communicate with each other using topics. You will write your own topics (publishers/subscribers) inside nodes and experiment with them.


































































